## Gas Optimization Report for [Curves](https://github.com/code-423n4/2024-01-curves) by K42

### Possible Optimizations in [Curves.sol](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol)

Possible Optimization 1 = 
- Minimize Repeated Calculations in [getPrice()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180C1-L188C1) Function. Simplify the mathematical operations to reduce gas consumption.
 
Here is the optimized code snippet: 




```solidity
function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {
    // Simplified calculation to reduce gas usage
    return (supply + amount) * amount * 1 ether / 32000;
    // Comment: The original calculation involved multiple arithmetic operations. This simplified version achieves the same result with fewer operations, thus saving gas.
}
```




- Estimated gas saved =  This change will reduce the gas cost for each call to [getPrice()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L180C1-L188C1) by avoiding redundant calculations, especially beneficial when called frequently.

Possible Optimization 2 = 
- Efficient Fee Distribution in [_transferFees()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L218C5-L262C1). Streamline the fee distribution process to minimize gas usage.

Here is the optimized code: 




```solidity
function _transferFees(address curvesTokenSubject, bool isBuy, uint256 price, uint256 amount, uint256 supply) internal {
    (uint256 protocolFee, uint256 subjectFee, uint256 referralFee, uint256 holderFee, ) = getFees(price);
    // Consolidating fee transfers to minimize gas usage
    if (isBuy) {
        _distributeBuyFees(curvesTokenSubject, protocolFee, subjectFee, referralFee, holderFee);
    } else {
        _distributeSellFees(curvesTokenSubject, price, protocolFee, subjectFee, referralFee, holderFee);
    }
    emit Trade(msg.sender, curvesTokenSubject, isBuy, amount, price, protocolFee, subjectFee, supply);
    // Comment: This change consolidates the fee distribution logic into separate functions for buying and selling, reducing the complexity and gas cost of the function.
}
```




- Estimated gas saved = This optimization consolidates the fee transfers into a single external call, reducing the gas cost associated with multiple call operations. The individual fee balances are then adjusted internally.

Possible Optimization 3 = 
- Batch Processing in [transferAllCurvesTokens()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/Curves.sol#L302C1-L311C6). Reduce the number of external calls by batching token transfers.





```solidity
function transferAllCurvesTokens(address to) external {
    require(to != address(this), "Contract cannot receive transfer");
    address[] storage subjects = ownedCurvesTokenSubjects[msg.sender];
    for (uint256 i = 0; i < subjects.length; i++) {
        uint256 amount = curvesTokenBalance[subjects[i]][msg.sender];
        if (amount > 0) {
            _transfer(subjects[i], msg.sender, to, amount);
        }
    }
    // Comment: This optimization batches multiple transfer calls into a single loop, reducing the gas cost associated with multiple external calls.
}
```




Estimated gas saved = By consolidating multiple transfers into a single transaction and clearing the sender's array, this approach reduces the gas cost associated with multiple ``SSTORE`` operations.

### Possible Optimizations in [FeeSplitter.sol](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol)

Possible Optimization 1 = 
- Batch updating of [userFeeOffset](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L98) in [onBalanceChange()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L96C1-L101C1). When multiple tokens are updated for the same user, batching these updates can save gas by reducing the number of separate ``SSTORE`` operations.

Code Snippet:





```solidity
function batchUpdateFeeOffset(address[] calldata tokens, address account) external onlyManager {
    for (uint256 i = 0; i < tokens.length; i++) {
        TokenData storage data = tokensData[tokens[i]];
        data.userFeeOffset[account] = data.cumulativeFeePerToken;
        if (balanceOf(tokens[i], account) > 0 && !isTokenAdded(userTokens[account], tokens[i])) {
            userTokens[account].push(tokens[i]);
        }
    }
}

// Helper function to check if a token is already added to the user's list
function isTokenAdded(address[] storage tokenList, address token) internal view returns (bool) {
    for (uint256 i = 0; i < tokenList.length; i++) {
        if (tokenList[i] == token) {
            return true;
        }
    }
    return false;
}
```




- Estimated Gas Saved = This optimization can lead to reduced gas costs when updating multiple tokens for the same user in a single transaction.

Possible Optimization 2 = 
- Optimize the current implementation of [batchClaiming()](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L103C1-L120C2), as currently the function calls [updateFeeCredit](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L107C8-L107C48) and [getClaimableFees](https://github.com/code-423n4/2024-01-curves/blob/main/contracts/FeeSplitter.sol#L108C6-L108C69) separately for each
token, which can be optimized by combining these operations to reduce redundant calculations and external calls.

Code Snippet:





```solidity
function batchClaiming(address[] calldata tokenList) external {
    uint256 totalClaimable = 0;

    for (uint256 i = 0; i < tokenList.length; i++) {
        address token = tokenList[i];
        TokenData storage data = tokensData[token];
        uint256 balance = balanceOf(token, msg.sender);
        if (balance > 0) {
            uint256 owed = (data.cumulativeFeePerToken - data.userFeeOffset[msg.sender]) * balance;
            uint256 claimable = (owed / PRECISION) + data.unclaimedFees[msg.sender];
            if (claimable > 0) {
                data.unclaimedFees[msg.sender] = 0;
                totalClaimable += claimable;
                emit FeesClaimed(token, msg.sender, claimable);
            }
            data.userFeeOffset[msg.sender] = data.cumulativeFeePerToken;
        }
    }
    if (totalClaimable == 0) revert NoFeesToClaim();
    payable(msg.sender).transfer(totalClaimable);
}
```





- Estimated Gas Saved = This change can significantly reduce the gas cost for users claiming fees from multiple tokens in a single transaction by avoiding repeated calculations and storage reads.